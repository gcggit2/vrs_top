
with open('app/reviews/data.ts', 'r', encoding='utf-8') as f:
    full_content = f.read()

# We need to replace the section from review94 to review85.
# Find start of review94 block
start_marker = "    id: 'review94',"
# Find start of review84 block (next page start)
end_marker = "    id: 'review84',"

parts = full_content.split(start_marker)

if len(parts) > 1:
    before_part = parts[0]
    # The rest contains review94...review84...
    rest = parts[1]
    
    parts2 = rest.split(end_marker)
    if len(parts2) > 1:
        after_part = parts2[1]
        
        # Read new snippet
        with open('page2_snippet.ts', 'r', encoding='utf-8') as f:
            snippet = f.read()
            
        # snippet starts with "  {\n    id: 'review94'..."
        # But we split at "    id: 'review94'," which is inside the object.
        # "before_part" ends with "  {\n" or similar.
        
        # Let's check the end of before_part
        # It should end with "  {\n" or ",\n  {\n"
        
        # Actually, let's just use the snippet as is, but we need to match the structure.
        # Snippet is a list of objects "  {\n    id..."
        
        # We need to construct the file:
        # [before_part UNTIL just before the opening brace of review94]
        # [snippet]
        # [comma]
        # [rest of file starting from review84 object]
        
        # Let's adjust the splitting logic.
        # Find the object start for review94.
        
        # In data.ts:
        #   },
        #   {
        #     id: 'review94',
        
        # Split by "id: 'review94'," is easy but loses the preceding lines.
        
        # Let's locate index
        idx_start = full_content.find("    id: 'review94',")
        if idx_start == -1:
            print("Error: review94 not found")
            exit(1)
            
        # Scan backwards to find the opening brace "  {"
        # It should be a few chars back.
        brace_idx = full_content.rfind("{", 0, idx_start)
        
        # Now find end marker "id: 'review84',"
        idx_end = full_content.find("    id: 'review84',")
        if idx_end == -1:
             print("Error: review84 not found")
             exit(1)
             
        brace_end_idx = full_content.rfind("{", 0, idx_end)
        
        # We will replace everything from brace_idx to brace_end_idx (exclusive)
        # with the snippet.
        
        # Wait, snippet contains review94 to review85 inclusive.
        # review84 is the start of the NEXT block.
        # So we replace from start of review94 object to start of review84 object.
        
        # snippet ends with "  },\n" (last item review85)
        # We might need a comma if it's not the last item. review84 exists, so yes.
        
        new_content = full_content[:brace_idx] + snippet + full_content[brace_end_idx:]
        
        # Check commas. 
        # full_content[:brace_idx] ends with "\n  " presumably (after previous item's comma)
        # snippet starts with "  {\n"
        # snippet ends with "  },\n"
        # full_content[brace_end_idx:] starts with "{\n    id: 'review84'..."
        
        # snippet has a trailing newline?
        snippet = snippet.strip() 
        if snippet.endswith(','):
             snippet = snippet[:-1] # Remove trailing comma if any, we'll control it
             
        # Actually page2_snippet.ts generated by us ends with "  },\n" for each item.
        # So it ends with "  },\n"
        
        # If we just concat:
        # ... },\n
        # [snippet ending with ,\n]
        # {\n id: review84...
        
        # Looks correct.
        
        # But wait, brace_idx points to "{". So we keep everything before it.
        # Previous line is likely "  },"
        
        with open('app/reviews/data.ts', 'w', encoding='utf-8') as f:
            f.write(new_content)
        print("Updated review94-85 successfully.")
        
    else:
        print("Error: review84 split failed")
else:
    print("Error: review94 split failed")



